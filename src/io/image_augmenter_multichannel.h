/*!
 *  Copyright (c) 2015 by Contributors
 * \file image_augmenter_opencv.hpp
 * \brief threaded version of page iterator
 */
#ifndef MXNET_IO_IMAGE_AUGMENTER_MULTICHANNEL_H_
#define MXNET_IO_IMAGE_AUGMENTER_MULTICHANNEL_H_

#if MXNET_USE_OPENCV
#include <opencv2/opencv.hpp>
#endif
#include <mxnet/base.h>
#include <utility>
#include <string>
#include <algorithm>
#include <vector>
#include "../common/utils.h"

namespace mxnet {
namespace io {
  
class rolling_counter {
    int count_;
    int max_;
  public:
    rolling_counter(int count,int max) : count_(count-1), max_(max){}
    
    int val(){
      count_++;
      if (count_ >= max_) count_ = 0;
      return count_;
    }
};


  
/*! \brief image augmentation parameters*/
struct ImageAugmentParam_multichannel : public dmlc::Parameter<ImageAugmentParam_multichannel> {
  /*! \brief whether we do random cropping */
  bool rand_crop;
  /*! \brief whether we do nonrandom croping */
  int crop_y_start;
  /*! \brief whether we do nonrandom croping */
  int crop_x_start;
  /*! \brief [-max_rotate_angle, max_rotate_angle] */
  int max_rotate_angle;
  /*! \brief max aspect ratio */
  float max_aspect_ratio;
  /*! \brief random shear the image [-max_shear_ratio, max_shear_ratio] */
  float max_shear_ratio;
  /*! \brief max crop size */
  int max_crop_size;
  /*! \brief min crop size */
  int min_crop_size;
  /*! \brief max scale ratio */
  float max_random_scale;
  /*! \brief min scale_ratio */
  float min_random_scale;
  /*! \brief min image size */
  float min_img_size;
  /*! \brief max image size */
  float max_img_size;
  /*! \brief max random in H channel */
  int random_h;
  /*! \brief max random in S channel */
  int random_s;
  /*! \brief max random in L channel */
  int random_l;
  /*! \brief rotate angle */
  int rotate;
  /*! \brief filled color while padding */
  int fill_value;
  /*! \brief interpolation method 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand  */
  int inter_method;
  /*! \brief shape of the image data*/
  TShape data_shape;
  // time rotation
  bool rand_time_rot;
    // shuffle saxes
  bool shuffle_sax;
  // normalize image input
  bool norm_images;
  // declare parameters
  DMLC_DECLARE_PARAMETER(ImageAugmentParam_multichannel) {
    DMLC_DECLARE_FIELD(rand_crop).set_default(false)
        .describe("Augmentation Param: Whether to random crop on the image");
    DMLC_DECLARE_FIELD(crop_y_start).set_default(-1)
        .describe("Augmentation Param: Where to nonrandom crop on y.");
    DMLC_DECLARE_FIELD(crop_x_start).set_default(-1)
        .describe("Augmentation Param: Where to nonrandom crop on x.");
    DMLC_DECLARE_FIELD(max_rotate_angle).set_default(0.0f)
        .describe("Augmentation Param: rotated randomly in [-max_rotate_angle, max_rotate_angle].");
    DMLC_DECLARE_FIELD(max_aspect_ratio).set_default(0.0f)
        .describe("Augmentation Param: denotes the max ratio of random aspect ratio augmentation.");
    DMLC_DECLARE_FIELD(max_shear_ratio).set_default(0.0f)
        .describe("Augmentation Param: denotes the max random shearing ratio.");
    DMLC_DECLARE_FIELD(max_crop_size).set_default(-1)
        .describe("Augmentation Param: Maximum crop size.");
    DMLC_DECLARE_FIELD(min_crop_size).set_default(-1)
        .describe("Augmentation Param: Minimum crop size.");
    DMLC_DECLARE_FIELD(max_random_scale).set_default(1.0f)
        .describe("Augmentation Param: Maxmum scale ratio.");
    DMLC_DECLARE_FIELD(min_random_scale).set_default(1.0f)
        .describe("Augmentation Param: Minimum scale ratio.");
    DMLC_DECLARE_FIELD(max_img_size).set_default(1e10f)
        .describe("Augmentation Param: Maxmum image size after resizing.");
    DMLC_DECLARE_FIELD(min_img_size).set_default(0.0f)
        .describe("Augmentation Param: Minimum image size after resizing.");
    DMLC_DECLARE_FIELD(random_h).set_default(0)
        .describe("Augmentation Param: Maximum value of H channel in HSL color space.");
    DMLC_DECLARE_FIELD(random_s).set_default(0)
        .describe("Augmentation Param: Maximum value of S channel in HSL color space.");
    DMLC_DECLARE_FIELD(random_l).set_default(0)
        .describe("Augmentation Param: Maximum value of L channel in HSL color space.");
    DMLC_DECLARE_FIELD(rotate).set_default(-1.0f)
        .describe("Augmentation Param: Rotate angle.");
    DMLC_DECLARE_FIELD(fill_value).set_default(255)
        .describe("Augmentation Param: Maximum value of illumination variation.");
    DMLC_DECLARE_FIELD(data_shape)
        .enforce_nonzero()
        .describe("Dataset Param: Shape of each instance generated by the DataIter.");
    DMLC_DECLARE_FIELD(inter_method).set_default(1)
        .describe("Augmentation Param: 0-NN 1-bilinear 2-cubic 3-area 4-lanczos4 9-auto 10-rand.");
    DMLC_DECLARE_FIELD(rand_time_rot).set_default(false)
        .describe("Augmentation Param: Whether to random rotate channels of the image");
    DMLC_DECLARE_FIELD(shuffle_sax).set_default(false)
        .describe("Augmentation Param: Whether to random shuffle saxes of the input");
    DMLC_DECLARE_FIELD(norm_images).set_default(false)
        .describe("Augmentation Param: Whether min-max normalize input images");
  }
};

/*! \brief helper class to do image augmentation */
class ImageAugmenter_Multichannel {
 public:
  // contructor
  ImageAugmenter_Multichannel(void) {
#if MXNET_USE_OPENCV
    rotateM_ = cv::Mat(2, 3, CV_32F);
#endif
  }
  virtual ~ImageAugmenter_Multichannel() {
  }
  virtual void Init(const std::vector<std::pair<std::string, std::string> >& kwargs) {
    std::vector<std::pair<std::string, std::string> > kwargs_left;
    kwargs_left = param_.InitAllowUnknown(kwargs);
    for (size_t i = 0; i < kwargs_left.size(); i++) {
        if (!strcmp(kwargs_left[i].first.c_str(), "rotate_list")) {
          const char* val = kwargs_left[i].second.c_str();
          const char *end = val + strlen(val);
          char buf[128];
          while (val < end) {
            sscanf(val, "%[^,]", buf);
            val += strlen(buf) + 1;
            rotate_list_.push_back(atoi(buf));
          }
        }
    }
  }
  /*!
   *\brief get interpolation method with given inter_method, 0-CV_INTER_NN 1-CV_INTER_LINEAR 2-CV_INTER_CUBIC
   *\ 3-CV_INTER_AREA 4-CV_INTER_LANCZOS4 9-AUTO(cubic for enlarge, area for shrink, bilinear for others) 10-RAND
   */
  virtual int GetInterMethod(int inter_method, int old_width, int old_height, int new_width,
          int new_height, common::RANDOM_ENGINE *prnd) {
      if (inter_method == 9) {
          if (new_width > old_width && new_height > old_height) {
            return 2;  // CV_INTER_CUBIC for enlarge
          } else if (new_width <old_width && new_height < old_height) {
            return 3;  // CV_INTER_AREA for shrink
          } else {
            return 1;  // CV_INTER_LINEAR for others
          }
      } else if (inter_method == 10) {
          std::uniform_int_distribution<size_t> rand_uniform_int(0, 4);
          return rand_uniform_int(*prnd);
      } else {
          return inter_method;
      }
  }
#if MXNET_USE_OPENCV
#ifdef _MSC_VER
#define M_PI CV_PI
#endif
    
  virtual void ProcessMultichannel(mshadow::Tensor<cpu,3> &src_tensor, std::vector<cv::Mat> & images,
			   common::RANDOM_ENGINE *prnd, index_t tensor_start_idx = 0) {
    using mshadow::index_t;
    cv::Mat res;

    //std::cout << images.size() << std::endl;
    
    /* Get input data as 3D Tensor object */
    //mshadow::Tensor<cpu, 3> src_tensor = src.get<cpu, 3, real_t>();
    //mshadow::TensorContainer<cpu, 3, real_t> src_tensor(mshadow::Shape3(param_.data_shape[0], param_.data_shape[1], param_.data_shape[2]));
    index_t d_shape_x = (param_.data_shape.ndim() == 4) ? param_.data_shape[3] : param_.data_shape[2];
    index_t d_shape_y = (param_.data_shape.ndim() == 4) ? param_.data_shape[2] : param_.data_shape[1];

    /* Declare affine-transformation parameters */
    float new_width = images[0].cols; 
    float new_height = images[0].rows;
    int interpolation_method = 1;
    cv::Mat M(2, 3, CV_32F);
    bool do_affine_trafo = false;
     
    /* Create the random numbers here to process each channel in the same manner */
    if (param_.max_rotate_angle > 0 || param_.max_shear_ratio > 0.0f
        || param_.rotate > 0 || rotate_list_.size() > 0 || param_.max_random_scale != 1.0
        || param_.min_random_scale != 1.0 || param_.max_aspect_ratio != 0.0f
        || param_.max_img_size != 1e10f || param_.min_img_size != 0.0f) {
      
      std::uniform_real_distribution<float> rand_uniform(0, 1);
      // shear
      float s = rand_uniform(*prnd) * param_.max_shear_ratio * 2 - param_.max_shear_ratio;
      // rotate
      int angle = std::uniform_int_distribution<int>(
	  -param_.max_rotate_angle, param_.max_rotate_angle)(*prnd);
      if (param_.rotate > 0) angle = param_.rotate;
      if (rotate_list_.size() > 0) {
	angle = rotate_list_[std::uniform_int_distribution<int>(0, rotate_list_.size() - 1)(*prnd)];
      }
      float a = cos(angle / 180.0 * M_PI);
      float b = sin(angle / 180.0 * M_PI);
      // scale
      float scale = rand_uniform(*prnd) *
	  (param_.max_random_scale - param_.min_random_scale) + param_.min_random_scale;
      // aspect ratio
      float ratio = rand_uniform(*prnd) *
	  param_.max_aspect_ratio * 2 - param_.max_aspect_ratio + 1;
      float hs = 2 * scale / (1 + ratio);
      float ws = ratio * hs;
      // new width and height
      new_width = std::max(param_.min_img_size,
				std::min(param_.max_img_size, scale * images[0].cols));
      new_height = std::max(param_.min_img_size,
				  std::min(param_.max_img_size, scale * images[0].rows));
      M.at<float>(0, 0) = hs * a - s * b * ws;
      M.at<float>(1, 0) = -b * ws;
      M.at<float>(0, 1) = hs * b + s * a * ws;
      M.at<float>(1, 1) = a * ws;
      float ori_center_width = M.at<float>(0, 0) * images[0].cols + M.at<float>(0, 1) * images[0].rows;
      float ori_center_height = M.at<float>(1, 0) * images[0].cols + M.at<float>(1, 1) * images[0].rows;
      M.at<float>(0, 2) = (new_width - ori_center_width) / 2;
      M.at<float>(1, 2) = (new_height - ori_center_height) / 2;
      CHECK((param_.inter_method >= 1 && param_.inter_method <= 4) ||
	(param_.inter_method >= 9 && param_.inter_method <= 10))
	  << "invalid inter_method: valid value 0,1,2,3,9,10";
      interpolation_method = GetInterMethod(param_.inter_method,
		    images[0].cols, images[0].rows, new_width, new_height, prnd);
      do_affine_trafo = true;      
    }
    
    /* Declare Crop paramters */
    index_t rand_crop_size = 0;
    index_t x = new_height;
    index_t y = new_width;
    bool do_crop = false;
    

    
    /* Create the random numbers here to crop each channel in the same manner */
    if (param_.max_crop_size != -1 || param_.min_crop_size != -1) {
      CHECK(new_height >= param_.max_crop_size && new_width >= \
              param_.max_crop_size && param_.max_crop_size >= param_.min_crop_size)
          << "input image size smaller than max_crop_size";
      rand_crop_size =
          std::uniform_int_distribution<index_t>(param_.min_crop_size, param_.max_crop_size)(*prnd);
	  
      
      y = new_width - rand_crop_size;
      x = new_height - rand_crop_size;
      if (param_.rand_crop != 0) {
        y = std::uniform_int_distribution<index_t>(0, y)(*prnd);
        x = std::uniform_int_distribution<index_t>(0, x)(*prnd);
      } else {
        y /= 2; x /= 2;
      }
      do_crop = true;
    }
    else {
      CHECK(static_cast<index_t>(new_width) >= d_shape_y
            && static_cast<index_t>(new_height) >= d_shape_x)
          << "input image size smaller than input shape";
      y = new_width - d_shape_y;
      x = new_height - d_shape_x;
      if (param_.rand_crop != 0) {
        y = std::uniform_int_distribution<index_t>(0, y)(*prnd);
        x = std::uniform_int_distribution<index_t>(0, x)(*prnd);
      } else {
        y /= 2; x /= 2;
      }
      //do_crop = true;
    }
    
    /* Declare color paramters */
    /*
    int h, s, l;
    int temp[3];
    int limit[3] = {180, 255, 255};
    */
    bool do_color_aug = false;
    
    /* Create random paramters for color augmentation */
    //if (param_.random_h != 0 || param_.random_s != 0 || param_.random_l != 0) {

    //std::cout << "COLOR AUGMENTATION IS NOT IMPLEMETED FOR MULTICHANNEL IMAGES" << std::endl;
      /*
      std::uniform_real_distribution<float> rand_uniform(0, 1);
      h = rand_uniform(*prnd) * param_.random_h * 2 - param_.random_h;
      s = rand_uniform(*prnd) * param_.random_s * 2 - param_.random_s;
      l = rand_uniform(*prnd) * param_.random_l * 2 - param_.random_l;
      temp[0] = h;
      temp[2] = l;
      temp[3] = s;
      do_color_aug = true;
      */
    //}

    
    
    /* Create random channel shift parameter */
    //if (param_.rand_time_rot) {
    int rand_frame = std::uniform_int_distribution<int>(0, src_tensor.shape_[0])(*prnd);
    rolling_counter count(rand_frame, src_tensor.shape_[0]);
    //}
    
    index_t seed = 0;
    std::vector<index_t> sax_idx(src_tensor.shape_[0]/30);
    std::iota(std::begin(sax_idx), std::end(sax_idx), 0);
    std::shuffle(sax_idx.begin(), sax_idx.end(), std::default_random_engine(seed));
      

    //std::cout << "loop stastd::cout << "fuckfuckfuck" << std::endl;rt" << std::endl;
    /* Augmentation for 3-channel packets of the multichannel input tensor */
    //for ( cv::Mat & src_img : images ) {
    for ( index_t pidx = 0; pidx < images.size(); ++pidx ) {
      /* Get the current 3-channel image to process */
      cv::Mat src_img = images[pidx];//ToMat_(src_tensor, pidx);
      
      /*
      //std::cout << "num channels " << src_img.channels() << std::endl;
      if (pidx == 0) { 
	cv::Mat tmp;
	std::cout << "end augmeter " << pidx << std::endl;
	cv::resize(src_img, tmp, cv::Size(256,256));
	cv::imshow("affine", tmp);
	cv::waitKey(0);
      }  
      */
      
      
    
      
      /* Apply the affine transformations */
      if ( do_affine_trafo ) {
	cv::warpAffine(src_img, temp_, M, cv::Size(new_width, new_height),
	      interpolation_method,
	      cv::BORDER_CONSTANT,
	      cv::Scalar(param_.fill_value, param_.fill_value, param_.fill_value));
	res = temp_;
	
	/*
	if (pidx == 0) { 
	  std::cout << "affine trafo " << pidx << std::endl;
	  cv::resize(res, tmp, cv::Size(256,256));
	  cv::imshow("affine", tmp);
	  cv::waitKey(0);
	}
	*/
      }
      else {
	
	res = src_img;
	/*
	if (pidx == 0) { 
	  std::cout << "no affine trafo" << std::endl;
	  cv::resize(res, tmp, cv::Size(256,256));
	  cv::imshow("affine", tmp);
	  cv::waitKey(0);
	}
	*/
      }
      
      /* Perform Crop */
      if ( do_crop ) {
	cv::Rect roi(x, y, rand_crop_size, rand_crop_size);
	interpolation_method = GetInterMethod(param_.inter_method, rand_crop_size, rand_crop_size,
					  d_shape_x, d_shape_y, prnd);

	res = res(roi);
	
	//cv::resize(res, res, cv::Size(d_shape_x, d_shape_y));
	
	/*
	if (pidx == 0) { 
	  std::cout << "do crop" << std::endl;
	  cv::resize(res, tmp, cv::Size(256,256));
	  cv::imshow("affine", tmp);
	  cv::waitKey(0);
	}
	*/
	//CHECK(res.rows == d_shape_y && res.cols == d_shape_x);
	
	cv::resize(res, res, cv::Size(d_shape_x, d_shape_y), 0, 0, interpolation_method);
	/*
	if (pidx == 0) {
	  std::cout << "do crop end" << pidx << std::endl;
	  cv::resize(res, tmp, cv::Size(256,256));
	  cv::imshow("do crop", tmp);
	  cv::waitKey(0);
	}
	*/
	
      }
      else {
	//y = res.rows - d_shape_y;
        //x = res.cols - d_shape_x;
	

	//std::cout << x << " " << y<< " " << d_shape_x << " "<< d_shape_y  << std::endl;
	cv::Rect roi(x, y, d_shape_x, d_shape_y);
        res = res(roi);
	/*
	if (pidx == 0) { 
	  std::cout << " not crop " << pidx << std::endl;
	  cv::resize(res, tmp, cv::Size(256,256));
	  cv::imshow("affine", tmp);
	  cv::waitKey(0);
	}
	*/
      }
      
      CHECK(static_cast<index_t>(res.rows) == d_shape_y && static_cast<index_t>(res.cols) == d_shape_x );      

      /* Perform color augmentation */
      if ( do_color_aug ) {
	std::cout << "COLOR AUGMENTATION IS NOT IMPLEMETED FOR MULTICHANNEL IMAGES" << std::endl;
	/*
	cvtColor(res, res, CV_BGR2HLS);
	for (int i = 0; i < res.rows; ++i) {
	  for (int j = 0; j < res.cols; ++j) {
	    for (int k = 0; k < 3; ++k) {
	      int v = res.at<cv::Vec3b>(i, j)[k];
	      v += temp[k];
	      v = std::max(0, std::min(limit[k], v));
	      res.at<cv::Vec3b>(i, j)[k] = v;
	    }
	  }
	}
	cvtColor(res, res, CV_HLS2BGR);
	*/
	/*
	std::uniform_real_distribution<float> rand_uniform(0, 1);
	//cvtColor(res, res, CV_BGR2HLS);
	int h = rand_uniform(*prnd) * 10 * 2 - 10;
	std::cout << "bias " << h << std::endl;
	for (int i = 0; i < res.rows; ++i) {
	  for (int j = 0; j < res.cols; ++j) {
	    for (int k = 0; k < 3; ++k) {
	      int v = res.at<cv::Vec3b>(i, j)[k];
	      v += h;
	      v = std::max(0, std::min(255, v));
	      res.at<cv::Vec3b>(i, j)[k] = v;
	    }
	  }
	}
	*/
      }
          


      /*
      //if (pidx == 0) {
	//cv::Mat tmp;
	std::cout << "affine trafo " << pidx << std::endl;
	cv::resize(res, tmp, cv::Size(256,256));
	cv::imshow("affine", tmp);
	cv::waitKey(0);
	*/
      //}
      
      
      index_t idx = (param_.rand_time_rot) ? count.val() : pidx; 
      //std::cout << idx << " " << pidx << " " << std::endl;
      /*
      index_t index = idx;
      if ( param_.shuffle_sax ) {
	index = sax_idx[idx/30] * 30 + (idx%30);
      }
      */
      
      /* Write changes to scr_tensor */
      ChannelToTensor_(src_tensor, res, idx+tensor_start_idx);
      //images[pidx] = res;
      /*
      if (param_.rand_time_rot) {
	int rand_frame = std::uniform_int_distribution<int>(0, src_tensor.shape_[0])(*prnd);
	rolling_counter count(rand_frame, src_tensor.shape_[0]);
	
	mshadow::Tensor<cpu, 3, real_t> tmp = mshadow::NewTensor<cpu, real_t>(mshadow::Shape3(src_tensor.shape_[0], src_tensor.shape_[1],src_tensor.shape_[2]), 0.0);
	for (index_t i = 0; i < src_tensor.shape_[0]; i++){	 
	  tmp[count.val()] = src_tensor[i];
	}
	src_tensor = tmp;
	mshadow::FreeSpace(&tmp);
      }
      */
      /*
      std::cout << "print start" << std::endl;
      for (index_t kk = 0; kk < 64*64; ++kk) {
	if (src_tensor[idx].dptr_[kk] != 0)
	  std::cout << src_tensor[idx].dptr_[kk] << std::endl;
      }
      
      //std::cout << "here1 " << " " << idx+tensor_start_idx << std::endl;
      if (pidx == 0) { 
      cv::Mat tmp;
      std::cout << "end augmeter " << pidx << std::endl;
      cv::resize(res, tmp, cv::Size(256,256));
      cv::imshow("affine", tmp);
      cv::waitKey(0);
      }  
       */
      
      //exit(-1);
    }
    /*
    //const real_t* data = src_tensor.dptr_;
    std::cout << "loop end" << std::endl;
    //TBlob* fucker = new TBlob((real_t*)data, param_.data_shape, cpu::kDevMask);
    for ( int i = 0; i < 200; i++ ) {
      std::cout << i << std::endl;
      std::cout << static_cast<real_t*>(src.dptr_)[i] << std::endl;
    }
    */
    //std::cout << "loop end" << std::endl;
    
  }
  
   
 private:
   
  
  void ChannelToTensor_(const mshadow::Tensor<cpu, 3> & tensor, cv::Mat & src_img, index_t ch_idx) {
    /* Write cv::Mat entry to channel 'ch_idx' of the source tensor */
    CHECK(src_img.channels() == 3)
      << "Image_augmenter_multichannel: ChannelToTensor_(), image has more than 1 channel!";
    for ( index_t i = 0; i < tensor.size(1); ++i ) {
      for ( index_t j = 0; j < tensor.size(2); ++j ) {
	//tensor[ch_idx][i][j] = static_cast<float>(src_img.at<unsigned char>(i, j));
	tensor[ch_idx][i][j] = static_cast<float>(src_img.at<cv::Vec3b>(i, j)[0]);
      }
    }
  }
  
 
  

#endif

 private:
#if MXNET_USE_OPENCV
  // temporal space
  cv::Mat temp_;
  // rotation param
  cv::Mat rotateM_;
#endif
  // parameters
  ImageAugmentParam_multichannel param_;
  /*! \brief list of possible rotate angle */
  std::vector<int> rotate_list_;
};
}  // namespace io
}  // namespace mxnet
#endif  // MXNET_IO_IMAGE_AUGMENTER_MULTICHANNEL_H_
